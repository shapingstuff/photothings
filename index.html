<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Spinner Display</title>
<style>
  html,body { height:100%; margin:0; background:#000; }
  #frame {
    display:block;
    width:100vw;
    height:100vh;
    object-fit:contain;
    background:#000;
    user-select:none;
    -webkit-user-drag: none;
  }
  body.idle { cursor:none; }
  /* Connection status indicator */
  #status {
    position: fixed;
    top: 10px;
    right: 10px;
    padding: 8px 12px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 12px;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s;
  }
  #status.show { opacity: 1; }
  #status.connected { background: #0a0; color: #fff; }
  #status.disconnected { background: #a00; color: #fff; }
  #status.reconnecting { background: #fa0; color: #000; }
</style>
</head>
<body>
  <div id="status">Connecting...</div>
  <img id="frame" src="" alt="slide" draggable="false" />
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<script>
/* CONFIG */
const BROKER = "192.168.68.80";
const PORT   = 9001;
const TOPIC  = "spinner/slideshow";
const USE_WSS = false;
const MQTT_USER = null;
const MQTT_PASS = null;
const DEBUG = true;

/* Health check - force reconnect if no messages for 5 minutes */
const HEALTH_CHECK_INTERVAL = 60000; // Check every minute
const MAX_SILENT_TIME = 5 * 60 * 1000; // 5 minutes

function dbg(...args) {
  if (!DEBUG) return;
  try {
    if (console && console.debug) {
      console.debug.apply(console, args);
    } else {
      console.log.apply(console, args);
    }
  } catch (e) {
    try { console.log('dbg exception', e); } catch (_) {}
  }
}

const frame = document.getElementById('frame');
const status = document.getElementById('status');

let lastSeq = -1;
let loading = false;
let pendingMsg = null;
let client = null;
let lastMessageTime = Date.now();
let healthCheckTimer = null;

function updateStatus(state, text) {
  status.textContent = text;
  status.className = `show ${state}`;
  setTimeout(() => {
    if (state === 'connected') {
      status.classList.remove('show');
    }
  }, 3000);
}

function healthCheck() {
  const now = Date.now();
  const timeSinceLastMessage = now - lastMessageTime;
  
  if (timeSinceLastMessage > MAX_SILENT_TIME) {
    console.warn(`No MQTT messages for ${Math.round(timeSinceLastMessage/1000)}s - forcing reconnect`);
    updateStatus('reconnecting', 'Reconnecting...');
    if (client) {
      client.end(true); // Force disconnect
    }
    setTimeout(connect, 1000);
  }
}

function connect() {
  // Clear any existing health check
  if (healthCheckTimer) {
    clearInterval(healthCheckTimer);
  }

  const scheme = USE_WSS ? 'wss' : 'ws';
  const url = `${scheme}://${BROKER}:${PORT}`;
  const opts = { 
    reconnectPeriod: 2000, 
    connectTimeout: 30000,
    keepalive: 60,
    clean: true
  };
  if (MQTT_USER) opts.username = MQTT_USER;
  if (MQTT_PASS) opts.password = MQTT_PASS;

  dbg('MQTT connecting to', url);
  updateStatus('reconnecting', 'Connecting...');
  
  client = mqtt.connect(url, opts);

  client.on('connect', () => {
    dbg('MQTT connected — subscribing to', TOPIC);
    updateStatus('connected', 'Connected');
    lastMessageTime = Date.now();
    
    client.subscribe(TOPIC, { qos: 0 }, (err) => {
      if (err) {
        console.error('Subscribe error:', err);
        updateStatus('disconnected', 'Subscribe failed');
      } else {
        dbg('Subscribed to', TOPIC);
      }
    });
    
    // Start health check
    healthCheckTimer = setInterval(healthCheck, HEALTH_CHECK_INTERVAL);
  });

  client.on('reconnect', () => {
    dbg('MQTT reconnecting...');
    updateStatus('reconnecting', 'Reconnecting...');
  });
  
  client.on('close', () => {
    dbg('MQTT connection closed');
    updateStatus('disconnected', 'Disconnected');
  });
  
  client.on('offline', () => {
    dbg('MQTT offline');
    updateStatus('disconnected', 'Offline');
  });
  
  client.on('error', (e) => {
    console.error('MQTT error:', e);
    updateStatus('disconnected', 'Error: ' + e.message);
  });

  client.on('message', (topic, payload) => {
    lastMessageTime = Date.now(); // Update health check
    try {
      const s = payload.toString();
      dbg('MQTT message', topic, s);
      const msg = JSON.parse(s);
      handleSlide(msg);
    } catch (e) {
      console.error('Failed to parse MQTT payload:', e, payload.toString());
    }
  });
}

function handleSlide(msg) {
  if (!msg || msg.type !== 'image' || !msg.url) {
    dbg('Ignoring non-image or malformed message:', msg);
    return;
  }

  const seq = (typeof msg.seq === 'number') ? msg.seq : Date.now();

  // Detect server restart: if seq jumps backwards significantly, reset
  if (seq < lastSeq && (lastSeq - seq) > 10) {
    console.warn(`Sequence jumped backwards (${lastSeq} -> ${seq}) - server likely restarted. Resetting.`);
    lastSeq = -1;
  }

  if (seq <= lastSeq) {
    dbg('Dropping older or duplicate seq', seq, '<=', lastSeq);
    return;
  }

  if (loading) {
    dbg('Image currently loading, queueing latest message.');
    pendingMsg = msg;
    return;
  }

  lastSeq = seq;
  pendingMsg = null;
  preloadAndShow(msg.url, seq, msg);
}

function preloadAndShow(url, seq, meta) {
  loading = true;
  dbg(`Preloading image seq=${seq} url=${url}`);

  const img = new Image();
  const cacheBusted = url + (url.includes('?') ? '&' : '?') + '_cb=' + Date.now();

  img.onload = () => {
    dbg(`Image seq=${seq} loaded successfully — displaying.`);
    frame.src = img.src;
    loading = false;
    if (pendingMsg) {
      const next = pendingMsg;
      pendingMsg = null;
      handleSlide(next);
    }
  };

  img.onerror = (ev) => {
    console.error(`Image seq=${seq} failed to load.`, ev);
    frame.src = cacheBusted;
    loading = false;
    if (pendingMsg) {
      const next = pendingMsg;
      pendingMsg = null;
      handleSlide(next);
    }
  };

  img.src = cacheBusted;
}

/* Idle cursor hide */
let idleTimer = null;
function resetIdle() {
  document.body.classList.remove('idle');
  clearTimeout(idleTimer);
  idleTimer = setTimeout(()=>document.body.classList.add('idle'), 2500);
}
['mousemove','touchstart','keydown'].forEach(e => document.addEventListener(e, resetIdle));
resetIdle();

/* Fullscreen toggle with 'f' key */
document.addEventListener('keydown', (ev) => {
  if (ev.key === 'f' || ev.key === 'F') {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(()=>{});
    } else {
      document.exitFullscreen().catch(()=>{});
    }
  }
  // 'r' to force reconnect (for debugging)
  if (ev.key === 'r' || ev.key === 'R') {
    console.log('Manual reconnect triggered');
    updateStatus('reconnecting', 'Manual reconnect...');
    if (client) client.end(true);
    setTimeout(connect, 500);
  }
});

// Start
connect();

window._spinnerDisplay = { client, handleSlide, preloadAndShow, connect, lastMessageTime };
</script>
</body>
</html>